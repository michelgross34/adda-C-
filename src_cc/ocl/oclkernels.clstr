"/* Kernel file for OpenCL kernels. Includes all subfunctions of the Matvec routine as OpenCL kernels\n"
" *\n"
" * Copyright (C) ADDA contributors\n"
" * This file is part of ADDA.\n"
" *\n"
" * ADDA is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as\n"
" * published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n"
" *\n"
" * ADDA is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty\n"
" * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n"
" *\n"
" * You should have received a copy of the GNU General Public License along with ADDA. If not, see\n"
" * <http://www.gnu.org/licenses/>.\n"
" */\n"
"// Somehow current AMD drivers do not define CL_VERSION_1_0 when compiling OpenCL kernels\n"
"//#ifndef CL_VERSION_1_0\n"
"//#	error \"OpenCL version at least 1.0 is required\"\n"
"//#endif\n"
"\n"
"//enable printf for debugging purposes on amd devices\n"
"//#pragma OPENCL EXTENSION cl_amd_printf : enable\n"
"\n"
"#ifdef USE_DOUBLE\n"
"#	ifdef DOUBLE_AMD\n"
"#		pragma OPENCL EXTENSION cl_amd_fp64 : enable\n"
"#	else\n"
"#		pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#	endif\n"
"#endif\n"
"\n"
"// defines type to work with variables defined as size_t in the main ADDA code\n"
"#ifdef SIZET_UINT\n"
"typedef uint in_sizet;\n"
"#elif defined(SIZET_ULONG)\n"
"typedef ulong in_sizet;\n"
"#else\n"
"#	error \"size_t alternative is not defined\"\n"
"#endif\n"
"\n"
"//======================================================================================================================\n"
"// functions used in kernels\n"
"\n"
"void cMult(__constant double2 *a,__global const double2 *b,__global double2 *c)\n"
"// complex multiplication; c=ab; !!! c should be different from a and b !!!\n"
"{\n"
"	(*c).s0=(*a).s0*(*b).s0 - (*a).s1*(*b).s1;\n"
"	(*c).s1=(*a).s1*(*b).s0 + (*a).s0*(*b).s1;\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"\n"
"void cMult2(__constant double2 *a,__global const double2 *b,double2 *c)\n"
"// complex multiplication; c=ab; !!! c should be different from a and b !!! c is private\n"
"{\n"
"	(*c).s0=(*a).s0*(*b).s0 - (*a).s1*(*b).s1;\n"
"	(*c).s1=(*a).s1*(*b).s0 + (*a).s0*(*b).s1;\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"\n"
"double cvNorm2(__global const double2 *a)\n"
"// square of the norm of a complex vector[3]\n"
"{\n"
"	return ( a[0].s0*a[0].s0 + a[0].s1*a[0].s1 + a[1].s0*a[1].s0 + a[1].s1*a[1].s1\n"
"	       + a[2].s0*a[2].s0 + a[2].s1*a[2].s1 );\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"// Arith1 kernels\n"
"\n"
"__kernel void nConj(__global double2 *a)\n"
"{\n"
"	const size_t id=get_global_id(0);\n"
"\n"
"	a[id].s1= -a[id].s1;\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"\n"
"__kernel void clzero(__global double2 *input)\n"
"{\n"
"	const size_t id = get_global_id(0);\n"
"\n"
"	input[id] = 0.0;\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"\n"
"__kernel void arith1(__global const uchar *material,__global const ushort *position,__constant double2 *cc_sqrt,\n"
"	__global const double2 *argvec, __global double2 *Xmatrix,const in_sizet local_Nsmall,const in_sizet smallY,\n"
"	const in_sizet gridX)\n"
"{\n"
"	const size_t id=get_global_id(0);\n"
"	const size_t j=3*id;\n"
"	const uchar mat=material[id];\n"
"	size_t index;\n"
"	int xcomp;\n"
"\n"
"	index = ((position[j+2]*smallY+position[j+1])*gridX+position[j]);\n"
"	for (xcomp=0;xcomp<3;xcomp++) cMult(&cc_sqrt[mat*3+xcomp],&argvec[j+xcomp],&Xmatrix[index+xcomp*local_Nsmall]);\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"// Arith2 kernel\n"
"\n"
"__kernel void arith2(__global const double2 *Xmatrix,__global double2 *slices,const in_sizet gridZ,\n"
"	const in_sizet smallY,const in_sizet gridX,const in_sizet gridYZ,const in_sizet local_Nsmall)\n"
"{\n"
"	const size_t xa=get_global_id(0);\n"
"	const size_t x=get_global_id(0)-get_global_offset(0);\n"
"	const size_t y=get_global_id(2);\n"
"	const size_t z=get_global_id(1);\n"
"	const size_t local_gridX=get_global_size(0);\n"
"	size_t i;\n"
"	size_t j;\n"
"	int xcomp;\n"
"\n"
"	i = y*gridZ+z+x*gridYZ;\n"
"	j = (z*smallY+y)*gridX+xa;\n"
"	for (xcomp=0;xcomp<3;xcomp++) {\n"
"		barrier(CLK_GLOBAL_MEM_FENCE);\n"
"		slices[i+xcomp*gridYZ*local_gridX]=Xmatrix[j+xcomp*local_Nsmall];\n"
"	}\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"// Arith3 kernels and functions\n"
"\n"
"void cSymMatrVec(const double2 *matr,const double2 *vec,double2 *res)\n"
"// multiplication of complex symmetric matrix[6] by complex vec[3]; res=matr.vec\n"
"{\n"
"	res[0].s0 = matr[0].s0*vec[0].s0 - matr[0].s1*vec[0].s1\n"
"	          + matr[1].s0*vec[1].s0 - matr[1].s1*vec[1].s1\n"
"	          + matr[2].s0*vec[2].s0 - matr[2].s1*vec[2].s1;\n"
"	res[0].s1 = matr[0].s0*vec[0].s1 + matr[0].s1*vec[0].s0\n"
"	          + matr[1].s0*vec[1].s1 + matr[1].s1*vec[1].s0\n"
"	          + matr[2].s0*vec[2].s1 + matr[2].s1*vec[2].s0;\n"
"\n"
"	res[1].s0 = matr[1].s0*vec[0].s0 - matr[1].s1*vec[0].s1\n"
"	          + matr[3].s0*vec[1].s0 - matr[3].s1*vec[1].s1\n"
"	          + matr[4].s0*vec[2].s0 - matr[4].s1*vec[2].s1;\n"
"	res[1].s1 = matr[1].s0*vec[0].s1 + matr[1].s1*vec[0].s0\n"
"	          + matr[3].s0*vec[1].s1 + matr[3].s1*vec[1].s0\n"
"	          + matr[4].s0*vec[2].s1 + matr[4].s1*vec[2].s0;\n"
"\n"
"	res[2].s0 = matr[2].s0*vec[0].s0 - matr[2].s1*vec[0].s1\n"
"	          + matr[4].s0*vec[1].s0 - matr[4].s1*vec[1].s1\n"
"	          + matr[5].s0*vec[2].s0 - matr[5].s1*vec[2].s1;\n"
"	res[2].s1 = matr[2].s0*vec[0].s1 + matr[2].s1*vec[0].s0\n"
"	          + matr[4].s0*vec[1].s1 + matr[4].s1*vec[1].s0\n"
"	          + matr[5].s0*vec[2].s1 + matr[5].s1*vec[2].s0;\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"\n"
"void cReflMatrVec(const double2 *matr,const double2 *vec,double2 *res)\n"
"/* multiplication of matrix[6] by complex vec[3]; res=matr.vec; passed components are the same as for symmetric matrix:\n"
" * 11,12,13,22,23,33, but the matrix has the following symmetry - M21=M12, M31=-M13, M32=-M23\n"
" */\n"
"{\n"
"	res[0].s0 = matr[0].s0*vec[0].s0 - matr[0].s1*vec[0].s1\n"
"	          + matr[1].s0*vec[1].s0 - matr[1].s1*vec[1].s1\n"
"	          + matr[2].s0*vec[2].s0 - matr[2].s1*vec[2].s1;\n"
"	res[0].s1 = matr[0].s0*vec[0].s1 + matr[0].s1*vec[0].s0\n"
"	          + matr[1].s0*vec[1].s1 + matr[1].s1*vec[1].s0\n"
"	          + matr[2].s0*vec[2].s1 + matr[2].s1*vec[2].s0;\n"
"\n"
"	res[1].s0 = matr[1].s0*vec[0].s0 - matr[1].s1*vec[0].s1\n"
"	          + matr[3].s0*vec[1].s0 - matr[3].s1*vec[1].s1\n"
"	          + matr[4].s0*vec[2].s0 - matr[4].s1*vec[2].s1;\n"
"	res[1].s1 = matr[1].s0*vec[0].s1 + matr[1].s1*vec[0].s0\n"
"	          + matr[3].s0*vec[1].s1 + matr[3].s1*vec[1].s0\n"
"	          + matr[4].s0*vec[2].s1 + matr[4].s1*vec[2].s0;\n"
"\n"
"	res[2].s0 = - matr[2].s0*vec[0].s0 + matr[2].s1*vec[0].s1\n"
"	            - matr[4].s0*vec[1].s0 + matr[4].s1*vec[1].s1\n"
"	            + matr[5].s0*vec[2].s0 - matr[5].s1*vec[2].s1;\n"
"	res[2].s1 = - matr[2].s0*vec[0].s1 - matr[2].s1*vec[0].s0\n"
"	            - matr[4].s0*vec[1].s1 - matr[4].s1*vec[1].s0\n"
"	            + matr[5].s0*vec[2].s1 + matr[5].s1*vec[2].s0;\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"\n"
"void cvAdd(const double2 *a, const double2 *b,double2 *c)\n"
"// adding two vectors c=a+b; addition is supported by opencl vector types\n"
"{\n"
"	c[0] = a[0] + b[0];\n"
"	c[1] = a[1] + b[1];\n"
"	c[2] = a[2] + b[2];\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"\n"
"__kernel void arith3(__global double2 *slices_tr,__global const double2 *Dmatrix,const in_sizet smallY,\n"
"	const in_sizet smallZ,const in_sizet gridX,const in_sizet DsizeY,const in_sizet DsizeZ,const char NDCOMP,\n"
"	const char reduced_FFT,const char transposed)\n"
"{\n"
"	size_t const y = get_global_id(0);\n"
"	size_t const z = get_global_id(1);\n"
"	// xl (local) is the index for the slices \n"
"	size_t const xl = get_global_id(2)-get_global_offset(2);\n"
"	// xa is the x index for Dmatrix\n"
"	size_t xa=get_global_id(2);\n"
"	size_t const gridY = get_global_size(0);\n"
"	size_t const gridZ = get_global_size(1);\n"
"	size_t const local_gridX = get_global_size(2);\n"
"	double2 xv[3];\n"
"	double2 yv[3];\n"
"	double2 fmat[6];\n"
"	int Xcomp;\n"
"	const size_t i=z *gridY + y; // indexSliceZY\n"
"	size_t j;\n"
"	size_t ya=y;\n"
"	size_t za=z;\n"
"\n"
"	// works, because of the double2 vector type\n"
"	for (Xcomp=0;Xcomp<3;Xcomp++) {\n"
"		barrier(CLK_GLOBAL_MEM_FENCE);\n"
"		xv[Xcomp]=slices_tr[i+(xl+Xcomp*local_gridX)*gridY*gridZ];\n"
"	}\n"
"	// indexDmatrix_mv\n"
"	if (transposed==1) { // almost never happens\n"
"		if (xa>0) xa=gridX-xa;\n"
"		if (y>0) ya=gridY-y;\n"
"		if (z>0) za=gridZ-z;\n"
"	}\n"
"	else {\n"
"		if (y>=DsizeY) ya=gridY-y;\n"
"		if (z>=DsizeZ) za=gridZ-z;\n"
"	}\n"
"	j=NDCOMP*(xa*DsizeY*DsizeZ+za*DsizeY+ya);\n"
"\n"
"	barrier(CLK_GLOBAL_MEM_FENCE);\n"
"	for (int f=0;f<6;f++) fmat[f]=Dmatrix[j+f];\n"
"\n"
"	if (reduced_FFT==1) {\n"
"		if (y>smallY) {\n"
"			fmat[1]*=-1;\n"
"			if (z>smallZ) fmat[2]*=-1;\n"
"			else fmat[4]*=-1;\n"
"		}\n"
"		else if (z>smallZ) {\n"
"			fmat[2]*=-1;\n"
"			fmat[4]*=-1;\n"
"		}\n"
"	}\n"
"	cSymMatrVec(fmat,xv,yv); // yv=fmat*xv\n"
"	for (Xcomp=0;Xcomp<3;Xcomp++) {\n"
"		barrier(CLK_GLOBAL_MEM_FENCE);\n"
"		slices_tr[i+(xl+Xcomp*local_gridX)*gridY*gridZ]=yv[Xcomp];\n"
"	}\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"\n"
"__kernel void arith3_surface(__global double2 *slices_tr,__global const double2 *Dmatrix,const in_sizet smallY,\n"
"	const in_sizet smallZ,const in_sizet gridX,const in_sizet DsizeY,const in_sizet DsizeZ,const char NDCOMP,\n"
"	const char reduced_FFT,const char transposed,const in_sizet RsizeY,__global double2 *slicesR_tr,\n"
"	__global const double2 *Rmatrix)\n"
"{\n"
"	size_t const y = get_global_id(0);\n"
"	size_t const z = get_global_id(1);\n"
"	size_t const x = get_global_id(2)-get_global_offset(2);\n"
"	size_t const gridY = get_global_size(0);\n"
"	size_t const gridZ = get_global_size(1);\n"
"	size_t const local_gridX = get_global_size(2);\n"
"	double2 xv[3];\n"
"	double2 yv[3];\n"
"	double2 xvR[3];\n"
"	double2 yvR[3];\n"
"	double2 fmat[6];\n"
"	int Xcomp;\n"
"	const size_t i=z *gridY + y; // indexSliceZY\n"
"	size_t j;\n"
"	//offset is needed for xa since it is used to calculate the index to Dmatrix\n"
"	size_t xa=x+get_global_offset(2);\n"
"	size_t ya=y;\n"
"	size_t za=z;\n"
"\n"
"	// works, because of the double2 vector type\n"
"	for (Xcomp=0;Xcomp<3;Xcomp++) {\n"
"		barrier(CLK_GLOBAL_MEM_FENCE);\n"
"		xv[Xcomp]=slices_tr[i+x*gridY*gridZ+Xcomp*gridY*gridZ*local_gridX];\n"
"	}\n"
"	// indexDmatrix_mv\n"
"	if (transposed==1) { // almost never happens\n"
"		if (x>0) xa=gridX-x;\n"
"		if (y>0) ya=gridY-y;\n"
"		if (z>0) za=gridZ-z;\n"
"	}\n"
"	else {\n"
"		if (y>=DsizeY) ya=gridY-y;\n"
"		if (z>=DsizeZ) za=gridZ-z;\n"
"	}\n"
"	j=NDCOMP*(xa*DsizeY*DsizeZ+za*DsizeY+ya);\n"
"\n"
"	barrier(CLK_GLOBAL_MEM_FENCE);\n"
"	for (int f=0;f<6;f++) fmat[f]=Dmatrix[j+f];\n"
"\n"
"	if (reduced_FFT==1) {\n"
"		if (y>smallY) {\n"
"			fmat[1]*=-1;\n"
"			if (z>smallZ) fmat[2]*=-1;\n"
"			else fmat[4]*=-1;\n"
"		}\n"
"		else if (z>smallZ) {\n"
"			fmat[2]*=-1;\n"
"			fmat[4]*=-1;\n"
"		}\n"
"	}\n"
"	cSymMatrVec(fmat,xv,yv); // yv=fmat*xv\n"
"	// surface part\n"
"	for (Xcomp=0;Xcomp<3;Xcomp++) {\n"
"		barrier(CLK_GLOBAL_MEM_FENCE);\n"
"		xvR[Xcomp]=slicesR_tr[i+x*gridY*gridZ+Xcomp*gridY*gridZ*local_gridX];\n"
"	}\n"
"	// indexRmatrix_mv; first resetting indices\n"
"	xa=x+get_global_offset(2);\n"
"	ya=y;\n"
"	za=z;\n"
"	if (transposed==1) { // almost never happens\n"
"		if ((x)>0) xa=gridX-x;\n"
"		else xa=x;\n"
"		if (y>0) ya=gridY-y;\n"
"		else ya=y;\n"
"	}\n"
"	else {\n"
"		if (y>=RsizeY) ya=gridY-y;\n"
"		else ya=y;\n"
"	}\n"
"\n"
"	j=NDCOMP*((xa*gridZ+za )*RsizeY+ya);\n"
"\n"
"	barrier(CLK_GLOBAL_MEM_FENCE);\n"
"	for (int f=0;f<6;f++) fmat[f]=Rmatrix[j+f];\n"
"\n"
"	if (reduced_FFT==1 && y>=RsizeY) {\n"
"		fmat[1]*=-1;\n"
"		fmat[4]*=-1;\n"
"	}\n"
"	if (transposed) { // almost never happens\n"
"		fmat[2]*=-1;\n"
"		fmat[4]*=-1;\n"
"	}\n"
"	// yv+=fmat.xvR\n"
"	cReflMatrVec(fmat,xvR,yvR);\n"
"	cvAdd(yvR,yv,yv);\n"
"	// surface part finished\n"
"	for (Xcomp=0;Xcomp<3;Xcomp++) {\n"
"		barrier(CLK_GLOBAL_MEM_FENCE);\n"
"		slices_tr[i+x*gridY*gridZ+Xcomp*gridY*gridZ*local_gridX]=yv[Xcomp];\n"
"	}\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"// Arith4 kernel\n"
"\n"
"__kernel void arith4(__global double2 *Xmatrix,__global const double2 *slices,const in_sizet gridZ,\n"
"	const in_sizet smallY,const in_sizet gridX,const in_sizet gridYZ,const in_sizet local_Nsmall)\n"
"{\n"
"	const size_t xa =get_global_id(0);\n"
"	const size_t x =get_global_id(0)-get_global_offset(0);\n"
"	const size_t z =get_global_id(1);\n"
"	const size_t y =get_global_id(2);\n"
"	const size_t local_gridX=get_global_size(0);\n"
"	size_t i;\n"
"	size_t j;\n"
"	int xcomp;\n"
"	double2 tmp;\n"
"\n"
"	i = y*gridZ+z+x*gridYZ;\n"
"	j = (z*smallY+y)*gridX+xa;\n"
"	for (xcomp=0;xcomp<3;xcomp++) {\n"
"		tmp=slices[i+xcomp*gridYZ*local_gridX];\n"
"		barrier(CLK_GLOBAL_MEM_FENCE);\n"
"		Xmatrix[j+xcomp*local_Nsmall]=tmp;\n"
"	}\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"// Arith5 kernel\n"
"\n"
"__kernel void arith5(__global const uchar *material,__global const ushort *position,__constant double2 *cc_sqrt,\n"
"	__global const double2 *argvec,__global const double2 *Xmatrix,const in_sizet local_Nsmall,const in_sizet smallY,\n"
"	const in_sizet gridX,__global double2 *resultvec)\n"
"{\n"
"	const size_t id = get_global_id(0);\n"
"	const size_t j=3*id;\n"
"	const uchar mat = material[id];\n"
"	size_t index;\n"
"	double2 temp;\n"
"	int xcomp;\n"
"\n"
"	index = ((position[j+2]*smallY+position[j+1])*gridX+position[j]);\n"
"	for (xcomp=0;xcomp<3;xcomp++) {\n"
"		cMult2(&cc_sqrt[mat*3+xcomp],&Xmatrix[index+xcomp*local_Nsmall],&temp);\n"
"		resultvec[j+xcomp]=argvec[j+xcomp]+temp;\n"
"	}\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"\n"
"__kernel void inpr(__global double *inprod, __global const double2 *resultvec)\n"
"{\n"
"	const size_t id = get_global_id(0);\n"
"\n"
"	inprod[id]=cvNorm2(resultvec+(id*3));\n"
"}\n"
"\n"
"//======================================================================================================================\n"
"// Optimized transpose kernel\n"
"// This corresponds to value of tblock in TransposeYZ() in fft.c\n"
"#define BLOCK_DIM 16\n"
"__kernel void transposeo(__global const double2 *idata,__global double2 *odata,const in_sizet width,\n"
"	const in_sizet height,__local double2 *block)\n"
"//optimised transpose kernel with cache and removed bank conflicts obtained from Nvidia SDK samples\n"
"{\n"
"	// read tiles into local memory\n"
"	size_t xIndex = get_global_id(0);\n"
"	size_t yIndex = get_global_id(1);\n"
"	const size_t zIndex = get_global_id(2);\n"
"	const size_t htw = height*width;\n"
"	if ((xIndex < width) && (yIndex < height)) {\n"
"		size_t index_in = yIndex * width + xIndex + htw * zIndex;\n"
"		block[get_local_id(1)*(BLOCK_DIM+1)+get_local_id(0)] = idata[index_in];\n"
"	}\n"
"	barrier(CLK_LOCAL_MEM_FENCE);\n"
"	// write transposed tile back to global memory\n"
"	xIndex = get_group_id(1) * BLOCK_DIM + get_local_id(0);\n"
"	yIndex = get_group_id(0) * BLOCK_DIM + get_local_id(1);\n"
"	if ((xIndex < height) && (yIndex < width)) {\n"
"		size_t index_out = yIndex * height + xIndex + htw * zIndex;\n"
"		odata[index_out] = block[get_local_id(0)*(BLOCK_DIM+1)+get_local_id(1)];\n"
"	}\n"
"}\n"


